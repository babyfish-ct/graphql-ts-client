# Code Generator

This framework provides a code generator to generate the client-side TypeScript code based on the graphql schema provided by remote service. Unlike most similar frameworks, the code generation work here is one-off. As long as the API provided by the service remains unchanged, you can generate the code only once and continue to develop it.


## Types of generators
So far, the framework provides three code generators: 
1. AsyncGenerator
2. ApolloGenerator
3. RelayGenerator

For the ObjectType, InterfaceType, UnionType, EnumType and InputType defined in GraphQL Schema, the codes generated by the three code generators are almost identical. The difference is that the result of code generation related to server-side HTTP communication is different.

No matter which code generator is used, this package must be imported in "--dev" mode
```
yarn add graphql-ts-client-codegen --dev
```

### 1. AsyncGenerator

Only generate the simplest async function named execute, accept parameters and return the execution result of the server. There are no additional features, such as react-hook style API and local cache management. The usage method is as follows (used in the script file of the project custom command under "scripts", not web project source code file under "src")
```js
const { AsyncGenerator, loadRemoteSchema } = require("graphql-ts-client-codegen");
const path = require("path");

const generator = new AsyncGenerator({
    schemaLoader: async() => {
      return loadRemoteSchema("http://localhost:8080/graphql");
    },
    targetDir: path.join(__dirname, "../src/__generated"),
    defaultFetcherExcludeMap: {
      "Department": ["avgSalary"]
    }
});

generator.generate();
```
Configurations can be passed in through constructor parameter, which will be described in detail in subsequent chapters.

In order to make the generated code can be compiled, the package needs to be imported
```
yarn add graphql-ts-client-api
```

### 2. ApolloGenerator

Generate client code based on @apollo/client, provide react-hook style API and local cache service. The usage method is as follows (used in the script file of the project custom command under "scripts", not web project source code file under "src")
```js
const { ApolloGenerator, loadRemoteSchema } = require("graphql-ts-client-codegen");
const path = require("path");

const generator = new ApolloGenerator({
    schemaLoader: async() => {
      return loadRemoteSchema("http://localhost:8080/graphql");
    },
    targetDir: path.join(__dirname, "../src/__generated"),
    defaultFetcherExcludeMap: {
      "Department": ["avgSalary"]
    }
});

generator.generate();
```
Configurations can be passed in through constructor parameter, which will be described in detail in subsequent chapters.

In order to make the generated code can be compiled, these packages need to be imported
```
yarn add \
    graphql \
    @apollo/client \
    graphql-ts-client-api
```

Finally, in the generated code, new API functions are generated to wrap the functions of @apollo/client API.

|Strongly typed API generated in src/__generated|@apollo/client API|
|----------|-------------|
|useTypedQuery|useQuery|
|useTypedLazyQuery|useLazyQuery|
|useTypedMutation|useMuation|

### 3. RelayGenerator

Generate relay-based client code, provide react-hook style API and local cache service. The usage method is as follows (used in the script file of the project custom command under "scripts", not web project source code file under "src")
```js
const { RelayGenerator, loadRemoteSchema } = require("graphql-ts-client-codegen");
const path = require("path");

const generator = new RelayGenerator({
    schemaLoader: async() => {
      return loadRemoteSchema("http://localhost:8080/graphql");
    },
    targetDir: path.join(__dirname, "../src/__generated"),
    defaultFetcherExcludeMap: {
      "Department": ["avgSalary"]
    }
});

generator.generate();
```

Configurations can be passed in through constructor parameter, which will be described in detail in subsequent chapters.

In order to make the generated code can be compiled, these packages need to be imported
```
yarn add \
    react-relay @types/react-relay \
    relay-runtime @types/relay-runtime \
    graphql-ts-client-api \
    graphql-ts-client-relay
```

Finally, in the generated code, new API functions are generated to wrap the functions of relay API.

|Strongly typed API generated in src/__generated|relay API|
|----------|-------------|
|loadTypedQuery|loadQuery|
|fetchTypedQuery|fetchQuery|
|useTypedQueryLoader|useQueryLoader|
|useTypedPreloadedQuery|usePreloadedQuery|
|useTypedLazyQuery|useLazyQuery|
|useTypedMutation|useMutation|
|useTypedFragment|useFragment|
|useTypedRefetchableFragment|useRefetchableFragment|
|useTypedPaginationFragment|usePaginationFragment|
|getConnection|ConnectionHandler.getConnection|
|getConnectionID|ConnectionHandler.getConnectionID|


## 4. Configurable properties

As mentioned above, no matter which Generator is used, its constructor needs a configuration object. The properties of this configuration object are as follows

|property|type|required|default value|
|--------|----|--------|-------------|
|schemaLoader|()=>Promise&lt;GraphQLSchema&gt;|true||
|targetDir|string|true||
|indent|string|false|"\t"|
|objectEditable|boolean|false|false|
|arrayEditable|boolean|false|false|
|fetcherSuffix|string|false|"Fetcher"|
|excludedTypes|string[]|false||
|scalarTypeMap|{[key:string:] string &#124; { readonly typeName: string, readonly importSource: string }}|false||
|defaultFetcherExcludeMap|{[key:string]: string[]}|false||
|tsEnum|boolean|false|false|

### schemaLoader
An asynchronous function with no parameters and returning Promise&lt;GraphQLSchema&gt;, used to obtain GraphQL schema information.

In order to implement this function more simply, graphql-ts-client-codegen provides two auxiliary functions, loadRemoteSchema and loadLocalSchema

```ts

export async function loadRemoteSchema(
    endpoint: string,
    headers?: { [key: string]: string }
): Promise<GraphQLSchema>;

export function loadLocalSchema(
    sdl: string
): GraphQLSchema;
```

loadRemoteSchema requires server address; loadLocalSchema request the schema defination languge text.

If neither of these two auxiliary methods can help you implement the schemaLoader, you can use any custom logic to implement it.

## targetDir
The target directory, all the generated code will be saved under it.

eg
```
+-project_home
|
+----+-scripts
|    |
|    \------GraphQLCodeGenerator.js // Your node script that use code generator
|
\----+-src
     |
     \------__generated // You want to generate code under this directory
```
for this direactory structure, you should specify it as "../src/__generated"

## objectEditable
Indicates whether the keyword "readonly" should **NOT** be used on the fields of generated object types. the default value is false so that "readonly" can be generated. This is helpful for immutable object culture of react. 

When it comes to modifying the data state based on immutable objects, [immer](https://github.com/immerjs/immer) is a recommended choice.


## arrayEditable
Indicates whether the keyword "readonly" should **NOT** be used on the array type of generated object fields. the default value is false so that "readonly" can be generated.

Look at this example

```
readonly items: readonly Item[];
```
The first "readonly" can be disabled by "objectEditable".

The second "readonly" can be disabled by "arrayEditable".

There is a situation where you have to let "arrayEditable" to be true. The low version API of [antd](https://ant.design/) does not accept the second "readonly", such as the property "dataSource" of &lt;Table/&gt;. However, the higher versions of antd have fixed this problem.

## excludedTypes
Indicates the graphql types that should be ignored.

This configuration will be validated by the GraphQL schema, all the spelling errors will be found and reported, please don't worry about spelling errors.

## scalarTypeMap

**Custom primary type**

Code generator can handle some scalar types by itself, but scalar type name can be defined as any text by server-side, not all the scalar types can be handled automatically, eg:

```
{
	"scalarTypeMap": { 
		"Int8": "number", 
		"Int16": "number",
		"Int32": "number", 
		"Int64": "number"
	}
}
```
Code generator will consider "Int8", "Int16", "Int32" and "Int64" to be "number" according to this configuration.

You can also use the configuration to override the default behavior of code generator. If the scalar type that can be automatically handled by code generator is configured here, the user configuration has higher priority.

**Custom inline type**

```
{
	"scalarTypeMap": { 
		"GraphQLPoint": "{readonly x: number, readonly: number}" 
                // Becareful, this value is string
	}
}
```

**Custom non-inline type**
```
{
	"scalarTypeMap": { 
		"GraphQLPoint": {
		    typeName: "Point",
		    importSource: "commons/Type"
                    // "import { Point } from '../common/Types';" will be generated
		}
	}
}
```

## defaultFetcherExcludeMap

For most ObjectTypes in GraphQL Schema, the code generator generates two built-in fetcher instances. For example, [example/client/async-demo/src/__generated/fetchers/DepartmentFetcher.ts](../example/client/async-demo/src/__generated/fetchers/DepartmentFetcher.ts) defines two instances:
```
export const department$: DepartmentFetcher<{}> = 
	createFetcher('employees');

export const department$$ = 
	department$
		.id
		.name
	;
```
The first one is empty fetcher, all the other fetchers should be create by it.

The second one is default fetcher, it contains the fields that are neither association nor parameterized. that means all the association fields and parameterized fields should be excluded form default fetcher. This configuration allows you to exclude more fields.(If all the fields are excluded by your configuration, the default fetcher itself will not be generated), eg:

```
{
	"defaultFetcherExcludeMap": {
		"ObjectType1": [ "field1OfType1", "field2OfType1"],
		"ObjectType2": [ "field1OfType2", "field2OfType2"]
	}
}
	
```

In all built-in demo projects of this framework, the Department.avgSalary property is excluded. Although it's neither association nor parameterized, As a calculated field, its performance overhead is not low. For performance considerations, it is excluded from the default Fetcher, like this
```
defaultFetcherExcludeMap: {
    "Department": ["avgSalary"]
}
```

This configuration will be validated by the GraphQL schema, all the spelling errors will be found and reported, please don't worry about spelling errors.

### tsEnum

-  If it is false(default), union types are generated for GraphQL enum types, like this
   ```
   export type Gender = "MALE" | "FEMALE";
   ```
-  If it is true or "number", generate typescript enum types, like this
   ```
   export enum Gender { MALE, FEMALE}
   ```
-  If it is "string", generate typescript enum types, like this
   ```
   export enum Gender { MALE = "MALE", FEMALE = "FEMALE"}
   ```
   > Note: Some techniques, such as recoil, are not friendly to TypeScript enum types. That's why it defaults to false.
____________________


[Back to document home](./README.md) | [Next: Core idea: Fetcher>](./fetcher/README.md)
